<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Game Hub - 8 Fun Games in One Page</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    body {
      background: linear-gradient(135deg, #1a2a6c, #b21f1f, #1a2a6c);
      color: white;
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    header {
      text-align: center;
      padding: 20px 0;
      margin-bottom: 30px;
    }

    h1 {
      font-size: 3rem;
      margin-bottom: 10px;
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
    }

    .subtitle {
      font-size: 1.2rem;
      opacity: 0.9;
    }

    nav {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 10px;
      margin: 20px 0 40px;
    }

    .nav-btn {
      background: rgba(255, 255, 255, 0.15);
      border: 2px solid rgba(255, 255, 255, 0.2);
      color: white;
      padding: 12px 20px;
      border-radius: 50px;
      cursor: pointer;
      font-size: 1rem;
      font-weight: 600;
      transition: all 0.3s ease;
    }

    .nav-btn:hover, .nav-btn.active {
      background: rgba(255, 255, 255, 0.3);
      transform: translateY(-3px);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    .game-container {
      display: none;
      background: rgba(0, 0, 0, 0.6);
      border-radius: 15px;
      padding: 30px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      animation: fadeIn 0.5s ease;
    }

    .game-container.active {
      display: block;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    .game-header {
      text-align: center;
      margin-bottom: 25px;
    }

    .game-title {
      font-size: 2.5rem;
      margin-bottom: 10px;
      color: #ffcc00;
    }

    .game-description {
      font-size: 1.1rem;
      max-width: 800px;
      margin: 0 auto 20px;
      line-height: 1.6;
    }

    .game-content {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .controls {
      display: flex;
      gap: 15px;
      margin-bottom: 25px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .btn {
      background: #4a69bd;
      color: white;
      border: none;
      padding: 12px 25px;
      border-radius: 50px;
      cursor: pointer;
      font-size: 1rem;
      font-weight: 600;
      transition: all 0.3s ease;
    }

    .btn:hover {
      background: #1e3799;
      transform: scale(1.05);
    }

    /* Tic Tac Toe Styles */
    #tic-tac-toe .board {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-gap: 10px;
      width: 300px;
      height: 300px;
      margin: 0 auto;
    }

    #tic-tac-toe .cell {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 3rem;
      font-weight: bold;
      cursor: pointer;
      transition: background 0.3s;
    }

    #tic-tac-toe .cell:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    #tic-tac-toe .status {
      font-size: 1.5rem;
      margin: 20px 0;
      text-align: center;
    }

    /* Snake Game Styles */
    #snake canvas {
      background: #000;
      border-radius: 10px;
      display: block;
      margin: 0 auto;
    }

    /* Memory Cards Styles */
    #memory-cards .cards-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 15px;
      max-width: 600px;
      margin: 0 auto;
    }

    #memory-cards .card {
      height: 100px;
      background: #4a69bd;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2rem;
      cursor: pointer;
      transition: transform 0.3s;
      position: relative;
      overflow: hidden;
    }

    #memory-cards .card.flipped {
      background: #fff;
      color: #4a69bd;
    }

    #memory-cards .card.matched {
      background: #2ecc71;
      color: white;
    }

    /* Pong Styles */
    #pong canvas {
      background: #000;
      border-radius: 10px;
      display: block;
      margin: 0 auto;
    }

    /* 2048 Styles */
    #game-2048 .grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      grid-gap: 10px;
      width: 300px;
      height: 300px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      padding: 10px;
      margin: 0 auto;
    }

    #game-2048 .grid-cell {
      background: rgba(255, 255, 255, 0.2);
      border-radius: 5px;
    }

    #game-2048 .tile {
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      border-radius: 5px;
      position: absolute;
    }

    /* Clicker Game Styles */
    #clicker-game .clicker-area {
      width: 200px;
      height: 200px;
      background: #ff9ff3;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
      font-weight: bold;
      cursor: pointer;
      margin: 20px auto;
      transition: transform 0.1s;
    }

    #clicker-game .clicker-area:active {
      transform: scale(0.95);
    }

    #clicker-game .stats {
      display: flex;
      justify-content: space-around;
      width: 100%;
      max-width: 500px;
      margin: 20px auto;
      text-align: center;
    }

    /* Maze Game Styles */
    #maze-game .maze {
      display: grid;
      grid-template-columns: repeat(10, 40px);
      gap: 2px;
      margin: 0 auto;
    }

    #maze-game .cell {
      width: 40px;
      height: 40px;
      background: #555;
    }

    #maze-game .path {
      background: #fff;
    }

    #maze-game .player {
      background: #2ecc71;
    }

    #maze-game .exit {
      background: #e74c3c;
    }

    /* Rock Paper Scissors Styles */
    #rock-paper-scissors .choices {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin: 20px 0;
    }

    #rock-paper-scissors .choice {
      width: 100px;
      height: 100px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2.5rem;
      cursor: pointer;
      transition: all 0.3s;
    }

    #rock-paper-scissors .choice:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: scale(1.1);
    }

    #rock-paper-scissors .result {
      font-size: 1.5rem;
      text-align: center;
      margin: 20px 0;
    }

    #rock-paper-scissors .score {
      display: flex;
      justify-content: space-around;
      width: 300px;
      margin: 20px auto;
    }

    /* Responsive Design */
    @media (max-width: 768px) {
      h1 {
        font-size: 2.2rem;
      }
      
      .game-title {
        font-size: 2rem;
      }
      
      .nav-btn {
        padding: 10px 15px;
        font-size: 0.9rem;
      }
      
      #memory-cards .cards-grid {
        grid-template-columns: repeat(3, 1fr);
      }
      
      #game-2048 .grid {
        width: 250px;
        height: 250px;
      }
    }

    @media (max-width: 480px) {
      .cards-grid {
        grid-template-columns: repeat(2, 1fr);
      }
      
      .controls {
        flex-direction: column;
        align-items: center;
      }
      
      .btn {
        width: 100%;
        max-width: 250px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>üéÆ Game Hub</h1>
      <p class="subtitle">8 Fun Games in One Place - Play Without Any Downloads!</p>
    </header>
    
    <nav>
      <button class="nav-btn active" data-game="home">Home</button>
      <button class="nav-btn" data-game="tic-tac-toe">Tic Tac Toe</button>
      <button class="nav-btn" data-game="snake">Snake</button>
      <button class="nav-btn" data-game="memory-cards">Memory Cards</button>
      <button class="nav-btn" data-game="pong">Pong</button>
      <button class="nav-btn" data-game="game-2048">2048</button>
      <button class="nav-btn" data-game="clicker-game">Clicker</button>
      <button class="nav-btn" data-game="maze-game">Maze</button>
      <button class="nav-btn" data-game="rock-paper-scissors">Rock Paper Scissors</button>
    </nav>
    
    <!-- Home Screen -->
    <div id="home" class="game-container active">
      <div class="game-header">
        <h2 class="game-title">Welcome to Game Hub!</h2>
        <p class="game-description">Explore our collection of 8 fun and interactive games. All games run entirely in your browser with no downloads required. Select a game from the navigation above to get started!</p>
      </div>
      <div class="game-content">
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; max-width: 1000px; margin: 0 auto;">
          <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 10px;">
            <h3>üéÆ Tic Tac Toe</h3>
            <p>Classic X and O game. Take turns with a friend to get three in a row!</p>
          </div>
          <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 10px;">
            <h3>üêç Snake</h3>
            <p>Navigate the snake to eat food and grow longer without hitting walls or yourself!</p>
          </div>
          <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 10px;">
            <h3>üÉè Memory Cards</h3>
            <p>Match pairs of cards. Test your memory skills!</p>
          </div>
          <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 10px;">
            <h3>üèì Pong</h3>
            <p>Classic arcade game. Use paddles to bounce the ball past your opponent!</p>
          </div>
          <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 10px;">
            <h3>üî¢ 2048</h3>
            <p>Combine tiles with the same numbers to reach the 2048 tile!</p>
          </div>
          <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 10px;">
            <h3>üëÜ Clicker</h3>
            <p>Click to earn points! Upgrade to increase your clicking power!</p>
          </div>
          <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 10px;">
            <h3>üß© Maze</h3>
            <p>Navigate through the maze to reach the exit!</p>
          </div>
          <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 10px;">
            <h3>‚úåÔ∏è Rock Paper Scissors</h3>
            <p>Play against the computer in this classic hand game!</p>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Tic Tac Toe -->
    <div id="tic-tac-toe" class="game-container">
      <div class="game-header">
        <h2 class="game-title">Tic Tac Toe</h2>
        <p class="game-description">Take turns placing X and O on the board. The first player to get 3 of their marks in a row (up, down, across, or diagonally) wins!</p>
      </div>
      <div class="game-content">
        <div class="controls">
          <button class="btn" id="tic-tac-toe-start">Start New Game</button>
        </div>
        <div class="status" id="tic-tac-toe-status">Player X's turn</div>
        <div class="board" id="tic-tac-toe-board"></div>
      </div>
    </div>
    
    <!-- Snake Game -->
    <div id="snake" class="game-container">
      <div class="game-header">
        <h2 class="game-title">Snake Game</h2>
        <p class="game-description">Control the snake to eat food and grow longer. Avoid hitting the walls or the snake's own body!</p>
      </div>
      <div class="game-content">
        <div class="controls">
          <button class="btn" id="snake-start">Start Game</button>
          <button class="btn" id="snake-pause">Pause</button>
        </div>
        <canvas id="snake-canvas" width="400" height="400"></canvas>
      </div>
    </div>
    
    <!-- Memory Cards -->
    <div id="memory-cards" class="game-container">
      <div class="game-header">
        <h2 class="game-title">Memory Cards</h2>
        <p class="game-description">Flip cards to find matching pairs. Remember the positions to complete the game with the fewest moves!</p>
      </div>
      <div class="game-content">
        <div class="controls">
          <button class="btn" id="memory-cards-start">Start Game</button>
        </div>
        <div class="cards-grid" id="memory-cards-grid"></div>
      </div>
    </div>
    
    <!-- Pong -->
    <div id="pong" class="game-container">
      <div class="game-header">
        <h2 class="game-title">Pong</h2>
        <p class="game-description">Control the paddle to bounce the ball past your opponent. First to score 5 points wins!</p>
      </div>
      <div class="game-content">
        <div class="controls">
          <button class="btn" id="pong-start">Start Game</button>
        </div>
        <canvas id="pong-canvas" width="600" height="400"></canvas>
      </div>
    </div>
    
    <!-- 2048 -->
    <div id="game-2048" class="game-container">
      <div class="game-header">
        <h2 class="game-title">2048</h2>
        <p class="game-description">Combine tiles with the same numbers to create a tile with the number 2048. Each move creates a new tile!</p>
      </div>
      <div class="game-content">
        <div class="controls">
          <button class="btn" id="game-2048-start">New Game</button>
        </div>
        <div class="grid" id="game-2048-grid"></div>
        <div>Score: <span id="game-2048-score">0</span></div>
      </div>
    </div>
    
    <!-- Clicker Game -->
    <div id="clicker-game" class="game-container">
      <div class="game-header">
        <h2 class="game-title">Clicker Game</h2>
        <p class="game-description">Click the button to earn points! Purchase upgrades to increase your clicking power and passive income!</p>
      </div>
      <div class="game-content">
        <div class="controls">
          <button class="btn" id="clicker-game-reset">Reset Game</button>
        </div>
        <div class="clicker-area" id="clicker-area">CLICK ME!</div>
        <div class="stats">
          <div>
            <div>Points</div>
            <div id="clicker-points">0</div>
          </div>
          <div>
            <div>Per Click</div>
            <div id="clicker-per-click">1</div>
          </div>
        </div>
        <div class="upgrades" id="clicker-upgrades"></div>
      </div>
    </div>
    
    <!-- Maze Game -->
    <div id="maze-game" class="game-container">
      <div class="game-header">
        <h2 class="game-title">Maze Game</h2>
        <p class="game-description">Navigate through the maze to reach the exit. Use arrow keys to move your character!</p>
      </div>
      <div class="game-content">
        <div class="controls">
          <button class="btn" id="maze-game-start">Generate Maze</button>
        </div>
        <div class="maze" id="maze-board"></div>
      </div>
    </div>
    
    <!-- Rock Paper Scissors -->
    <div id="rock-paper-scissors" class="game-container">
      <div class="game-header">
        <h2 class="game-title">Rock Paper Scissors</h2>
        <p class="game-description">Choose rock, paper, or scissors. Rock beats scissors, scissors beats paper, and paper beats rock!</p>
      </div>
      <div class="game-content">
        <div class="controls">
          <button class="btn" id="rps-reset">Reset Score</button>
        </div>
        <div class="choices">
          <div class="choice" id="rock">‚úä</div>
          <div class="choice" id="paper">‚úã</div>
          <div class="choice" id="scissors">‚úåÔ∏è</div>
        </div>
        <div class="result" id="rps-result">Choose your move!</div>
        <div class="score">
          <div>You: <span id="rps-player-score">0</span></div>
          <div>Computer: <span id="rps-computer-score">0</span></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Navigation functionality
    document.querySelectorAll('.nav-btn').forEach(button => {
      button.addEventListener('click', () => {
        // Update active nav button
        document.querySelectorAll('.nav-btn').forEach(btn => btn.classList.remove('active'));
        button.classList.add('active');
        
        // Hide all game containers
        document.querySelectorAll('.game-container').forEach(container => {
          container.classList.remove('active');
        });
        
        // Show selected game container
        const gameId = button.getAttribute('data-game');
        document.getElementById(gameId).classList.add('active');
      });
    });

    // Tic Tac Toe Game
    const ticTacToe = {
      board: ['', '', '', '', '', '', '', '', ''],
      currentPlayer: 'X',
      gameOver: false,
      
      init() {
        const boardElement = document.getElementById('tic-tac-toe-board');
        boardElement.innerHTML = '';
        
        for (let i = 0; i < 9; i++) {
          const cell = document.createElement('div');
          cell.classList.add('cell');
          cell.setAttribute('data-index', i);
          cell.addEventListener('click', () => this.makeMove(i));
          boardElement.appendChild(cell);
        }
        
        this.reset();
      },
      
      reset() {
        this.board = ['', '', '', '', '', '', '', '', ''];
        this.currentPlayer = 'X';
        this.gameOver = false;
        document.getElementById('tic-tac-toe-status').textContent = "Player X's turn";
        
        document.querySelectorAll('#tic-tac-toe-board .cell').forEach((cell, index) => {
          cell.textContent = '';
          cell.style.background = 'rgba(255, 255, 255, 0.1)';
        });
      },
      
      makeMove(index) {
        if (this.gameOver || this.board[index] !== '') return;
        
        this.board[index] = this.currentPlayer;
        document.querySelectorAll('#tic-tac-toe-board .cell')[index].textContent = this.currentPlayer;
        
        if (this.checkWinner()) {
          document.getElementById('tic-tac-toe-status').textContent = `Player ${this.currentPlayer} wins!`;
          this.gameOver = true;
          return;
        }
        
        if (this.board.every(cell => cell !== '')) {
          document.getElementById('tic-tac-toe-status').textContent = "It's a draw!";
          this.gameOver = true;
          return;
        }
        
        this.currentPlayer = this.currentPlayer === 'X' ? 'O' : 'X';
        document.getElementById('tic-tac-toe-status').textContent = `Player ${this.currentPlayer}'s turn`;
      },
      
      checkWinner() {
        const winPatterns = [
          [0, 1, 2], [3, 4, 5], [6, 7, 8], // rows
          [0, 3, 6], [1, 4, 7], [2, 5, 8], // columns
          [0, 4, 8], [2, 4, 6]             // diagonals
        ];
        
        for (const pattern of winPatterns) {
          const [a, b, c] = pattern;
          if (
            this.board[a] !== '' && 
            this.board[a] === this.board[b] && 
            this.board[a] === this.board[c]
          ) {
            // Highlight winning cells
            document.querySelectorAll('#tic-tac-toe-board .cell')[a].style.background = '#2ecc71';
            document.querySelectorAll('#tic-tac-toe-board .cell')[b].style.background = '#2ecc71';
            document.querySelectorAll('#tic-tac-toe-board .cell')[c].style.background = '#2ecc71';
            return true;
          }
        }
        return false;
      }
    };

    // Initialize Tic Tac Toe
    document.getElementById('tic-tac-toe-start').addEventListener('click', () => {
      ticTacToe.init();
      ticTacToe.reset();
    });
    
    // Initialize on load
    window.addEventListener('load', () => {
      ticTacToe.init();
    });

    // Snake Game
    const snakeGame = {
      canvas: null,
      ctx: null,
      snake: [],
      food: {},
      direction: 'right',
      nextDirection: 'right',
      gameInterval: null,
      gridSize: 20,
      gridWidth: 20,
      gridHeight: 20,
      gameRunning: false,
      
      init() {
        this.canvas = document.getElementById('snake-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.reset();
      },
      
      reset() {
        this.snake = [
          {x: 10, y: 10},
          {x: 9, y: 10},
          {x: 8, y: 10}
        ];
        this.direction = 'right';
        this.nextDirection = 'right';
        this.generateFood();
        this.draw();
      },
      
      generateFood() {
        let newFood;
        do {
          newFood = {
            x: Math.floor(Math.random() * this.gridWidth),
            y: Math.floor(Math.random() * this.gridHeight)
          };
          // Make sure food doesn't appear on snake
        } while (this.snake.some(segment => segment.x === newFood.x && segment.y === newFood.y));
        
        this.food = newFood;
      },
      
      move() {
        this.direction = this.nextDirection;
        
        const head = {...this.snake[0]};
        
        switch (this.direction) {
          case 'up':
            head.y -= 1;
            break;
          case 'down':
            head.y += 1;
            break;
          case 'left':
            head.x -= 1;
            break;
          case 'right':
            head.x += 1;
            break;
        }
        
        // Check collision with walls
        if (
          head.x < 0 || 
          head.x >= this.gridWidth || 
          head.y < 0 || 
          head.y >= this.gridHeight
        ) {
          this.gameOver();
          return;
        }
        
        // Check collision with self
        if (this.snake.some(segment => segment.x === head.x && segment.y === head.y)) {
          this.gameOver();
          return;
        }
        
        this.snake.unshift(head);
        
        // Check if food is eaten
        if (head.x === this.food.x && head.y === this.food.y) {
          this.generateFood();
        } else {
          this.snake.pop();
        }
        
        this.draw();
      },
      
      draw() {
        // Clear canvas
        this.ctx.fillStyle = '#000';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Draw snake
        this.ctx.fillStyle = '#4cd137';
        for (let i = 0; i < this.snake.length; i++) {
          this.ctx.fillRect(
            this.snake[i].x * this.gridSize, 
            this.snake[i].y * this.gridSize, 
            this.gridSize - 1, 
            this.gridSize - 1
          );
        }
        
        // Draw food
        this.ctx.fillStyle = '#e84118';
        this.ctx.fillRect(
          this.food.x * this.gridSize, 
          this.food.y * this.gridSize, 
          this.gridSize - 1, 
          this.gridSize - 1
        );
      },
      
      start() {
        if (this.gameInterval) clearInterval(this.gameInterval);
        this.gameRunning = true;
        this.gameInterval = setInterval(() => {
          this.move();
        }, 150);
      },
      
      pause() {
        if (this.gameInterval) {
          clearInterval(this.gameInterval);
          this.gameInterval = null;
          this.gameRunning = false;
        }
      },
      
      gameOver() {
        clearInterval(this.gameInterval);
        this.gameRunning = false;
        alert('Game Over! Your snake crashed.');
      }
    };

    // Initialize Snake
    document.getElementById('snake-start').addEventListener('click', () => {
      if (!snakeGame.gameRunning) {
        snakeGame.start();
      } else {
        snakeGame.pause();
        document.getElementById('snake-start').textContent = 'Resume';
      }
    });
    
    document.getElementById('snake-pause').addEventListener('click', () => {
      snakeGame.pause();
      document.getElementById('snake-start').textContent = 'Start Game';
    });
    
    // Keyboard controls for snake
    document.addEventListener('keydown', (e) => {
      if (!snakeGame.gameRunning) return;
      
      switch (e.key) {
        case 'ArrowUp':
          if (snakeGame.direction !== 'down') snakeGame.nextDirection = 'up';
          break;
        case 'ArrowDown':
          if (snakeGame.direction !== 'up') snakeGame.nextDirection = 'down';
          break;
        case 'ArrowLeft':
          if (snakeGame.direction !== 'right') snakeGame.nextDirection = 'left';
          break;
        case 'ArrowRight':
          if (snakeGame.direction !== 'left') snakeGame.nextDirection = 'right';
          break;
      }
    });
    
    // Initialize on load
    window.addEventListener('load', () => {
      snakeGame.init();
    });

    // Memory Cards Game
    const memoryCards = {
      cards: [],
      flippedCards: [],
      matchedPairs: 0,
      moves: 0,
      
      init() {
        const emojis = ['üê∂', 'üê±', 'üê≠', 'üêπ', 'üê∞', 'ü¶ä', 'üêª', 'üêº'];
        this.cards = [...emojis, ...emojis];
        this.shuffleArray(this.cards);
        this.flippedCards = [];
        this.matchedPairs = 0;
        this.moves = 0;
        
        const grid = document.getElementById('memory-cards-grid');
        grid.innerHTML = '';
        
        this.cards.forEach((emoji, index) => {
          const card = document.createElement('div');
          card.classList.add('card');
          card.dataset.index = index;
          card.dataset.value = emoji;
          card.textContent = '?';
          
          card.addEventListener('click', () => this.flipCard(card));
          
          grid.appendChild(card);
        });
      },
      
      shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
      },
      
      flipCard(card) {
        if (card.classList.contains('flipped') || card.classList.contains('matched')) {
          return;
        }
        
        if (this.flippedCards.length === 2) {
          return;
        }
        
        card.classList.add('flipped');
        card.textContent = card.dataset.value;
        this.flippedCards.push(card);
        
        if (this.flippedCards.length === 2) {
          this.moves++;
          this.checkForMatch();
        }
      },
      
      checkForMatch() {
        const [card1, card2] = this.flippedCards;
        
        if (card1.dataset.value === card2.dataset.value) {
          // Match found
          card1.classList.add('matched');
          card2.classList.add('matched');
          this.matchedPairs++;
          
          this.flippedCards = [];
          
          if (this.matchedPairs === 8) {
            setTimeout(() => {
              alert(`Congratulations! You won in ${this.moves} moves!`);
            }, 500);
          }
        } else {
          // No match, flip back after delay
          setTimeout(() => {
            card1.classList.remove('flipped');
            card2.classList.remove('flipped');
            card1.textContent = '?';
            card2.textContent = '?';
            this.flippedCards = [];
          }, 1000);
        }
      }
    };

    // Initialize Memory Cards
    document.getElementById('memory-cards-start').addEventListener('click', () => {
      memoryCards.init();
    });

    // Pong Game
    const pongGame = {
      canvas: null,
      ctx: null,
      leftPaddle: { x: 10, y: 150, width: 10, height: 100 },
      rightPaddle: { x: 580, y: 150, width: 10, height: 100 },
      ball: { x: 300, y: 200, radius: 10, dx: 5, dy: 5 },
      leftScore: 0,
      rightScore: 0,
      gameInterval: null,
      
      init() {
        this.canvas = document.getElementById('pong-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.reset();
      },
      
      reset() {
        this.leftPaddle.y = 150;
        this.rightPaddle.y = 150;
        this.ball.x = 300;
        this.ball.y = 200;
        this.ball.dx = (Math.random() > 0.5 ? 1 : -1) * 5;
        this.ball.dy = (Math.random() * 4) - 2; // Random vertical direction
        this.leftScore = 0;
        this.rightScore = 0;
        this.draw();
      },
      
      update() {
        // Move the ball
        this.ball.x += this.ball.dx;
        this.ball.y += this.ball.dy;
        
        // Ball collision with top and bottom walls
        if (this.ball.y <= 0 || this.ball.y >= this.canvas.height - this.ball.radius * 2) {
          this.ball.dy = -this.ball.dy;
        }
        
        // Ball collision with paddles
        if (
          this.ball.x <= this.leftPaddle.x + this.leftPaddle.width &&
          this.ball.y >= this.leftPaddle.y &&
          this.ball.y <= this.leftPaddle.y + this.leftPaddle.height
        ) {
          this.ball.dx = -this.ball.dx;
          // Add some angle based on where the ball hits the paddle
          const hitPosition = (this.ball.y - this.leftPaddle.y) / this.leftPaddle.height;
          this.ball.dy = (hitPosition - 0.5) * 10;
        }
        
        if (
          this.ball.x >= this.rightPaddle.x - this.ball.radius * 2 &&
          this.ball.y >= this.rightPaddle.y &&
          this.ball.y <= this.rightPaddle.y + this.rightPaddle.height
        ) {
          this.ball.dx = -this.ball.dx;
          // Add some angle based on where the ball hits the paddle
          const hitPosition = (this.ball.y - this.rightPaddle.y) / this.rightPaddle.height;
          this.ball.dy = (hitPosition - 0.5) * 10;
        }
        
        // Scoring
        if (this.ball.x < 0) {
          this.rightScore++;
          this.resetBall();
        } else if (this.ball.x > this.canvas.width) {
          this.leftScore++;
          this.resetBall();
        }
        
        // AI for right paddle
        const paddleCenter = this.rightPaddle.y + this.rightPaddle.height / 2;
        if (paddleCenter < this.ball.y - 35) {
          this.rightPaddle.y += 6;
        } else if (paddleCenter > this.ball.y + 35) {
          this.rightPaddle.y -= 6;
        }
        
        // Keep paddles in bounds
        if (this.leftPaddle.y < 0) this.leftPaddle.y = 0;
        if (this.leftPaddle.y > this.canvas.height - this.leftPaddle.height) this.leftPaddle.y = this.canvas.height - this.leftPaddle.height;
        if (this.rightPaddle.y < 0) this.rightPaddle.y = 0;
        if (this.rightPaddle.y > this.canvas.height - this.rightPaddle.height) this.rightPaddle.y = this.canvas.height - this.rightPaddle.height;
        
        this.draw();
        
        // Check for winner
        if (this.leftScore >= 5 || this.rightScore >= 5) {
          clearInterval(this.gameInterval);
          alert(`Game Over! ${this.leftScore >= 5 ? 'Left Player' : 'Right Player'} wins!`);
        }
      },
      
      resetBall() {
        this.ball.x = 300;
        this.ball.y = 200;
        this.ball.dx = (Math.random() > 0.5 ? 1 : -1) * 5;
        this.ball.dy = (Math.random() * 4) - 2;
      },
      
      draw() {
        // Clear canvas
        this.ctx.fillStyle = '#000';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Draw paddles
        this.ctx.fillStyle = '#fff';
        this.ctx.fillRect(this.leftPaddle.x, this.leftPaddle.y, this.leftPaddle.width, this.leftPaddle.height);
        this.ctx.fillRect(this.rightPaddle.x, this.rightPaddle.y, this.rightPaddle.width, this.rightPaddle.height);
        
        // Draw ball
        this.ctx.beginPath();
        this.ctx.arc(this.ball.x, this.ball.y, this.ball.radius, 0, Math.PI * 2);
        this.ctx.fill();
        
        // Draw scores
        this.ctx.font = '40px Arial';
        this.ctx.fillText(this.leftScore, 200, 50);
        this.ctx.fillText(this.rightScore, 400, 50);
        
        // Draw center line
        this.ctx.setLineDash([5, 15]);
        this.ctx.beginPath();
        this.ctx.moveTo(300, 0);
        this.ctx.lineTo(300, this.canvas.height);
        this.ctx.strokeStyle = '#fff';
        this.ctx.stroke();
        this.ctx.setLineDash([]);
      },
      
      start() {
        if (this.gameInterval) clearInterval(this.gameInterval);
        this.gameInterval = setInterval(() => {
          this.update();
        }, 30);
      }
    };

    // Initialize Pong
    document.getElementById('pong-start').addEventListener('click', () => {
      pongGame.start();
    });
    
    // Keyboard controls for left paddle (W/S keys)
    document.addEventListener('keydown', (e) => {
      if (document.getElementById('pong').classList.contains('active')) {
        if (e.key === 'w' || e.key === 'W') {
          pongGame.leftPaddle.y = Math.max(0, pongGame.leftPaddle.y - 20);
        } else if (e.key === 's' || e.key === 'S') {
          pongGame.leftPaddle.y = Math.min(
            pongGame.canvas.height - pongGame.leftPaddle.height, 
            pongGame.leftPaddle.y + 20
          );
        }
      }
    });
    
    // Initialize on load
    window.addEventListener('load', () => {
      pongGame.init();
    });

    // 2048 Game
    const game2048 = {
      grid: [],
      score: 0,
      gridSize: 4,
      
      init() {
        this.grid = Array(this.gridSize).fill().map(() => Array(this.gridSize).fill(0));
        this.score = 0;
        this.addRandomTile();
        this.addRandomTile();
        this.draw();
      },
      
      addRandomTile() {
        const emptyCells = [];
        for (let r = 0; r < this.gridSize; r++) {
          for (let c = 0; c < this.gridSize; c++) {
            if (this.grid[r][c] === 0) {
              emptyCells.push({r, c});
            }
          }
        }
        
        if (emptyCells.length > 0) {
          const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
          this.grid[randomCell.r][randomCell.c] = Math.random() < 0.9 ? 2 : 4;
        }
      },
      
      draw() {
        const gridElement = document.getElementById('game-2048-grid');
        gridElement.innerHTML = '';
        
        // Create background cells
        for (let i = 0; i < this.gridSize * this.gridSize; i++) {
          const cell = document.createElement('div');
          cell.classList.add('grid-cell');
          gridElement.appendChild(cell);
        }
        
        // Create tile elements
        for (let r = 0; r < this.gridSize; r++) {
          for (let c = 0; c < this.gridSize; c++) {
            if (this.grid[r][c] !== 0) {
              const tileValue = this.grid[r][c];
              const tile = document.createElement('div');
              tile.classList.add('tile');
              tile.textContent = tileValue;
              
              // Set tile colors based on value
              const colors = {
                2: '#eee4da', 4: '#ede0c8', 8: '#f2b179', 
                16: '#f59563', 32: '#f67c5f', 64: '#f65e3b', 
                128: '#edcf72', 256: '#edcc61', 512: '#edc850', 
                1024: '#edc53f', 2048: '#edc22e'
              };
              
              tile.style.backgroundColor = colors[tileValue] || '#3c3a32';
              tile.style.color = tileValue > 4 ? '#f9f6f2' : '#776e65';
              tile.style.fontSize = tileValue > 1000 ? '20px' : '25px';
              
              tile.style.width = `calc(25% - 10px)`;
              tile.style.height = `calc(25% - 10px)`;
              tile.style.position = 'absolute';
              tile.style.top = `${r * 25}%`;
              tile.style.left = `${c * 25}%`;
              tile.style.transform = 'translate(10px, 10px)';
              
              gridElement.appendChild(tile);
            }
          }
        }
        
        document.getElementById('game-2048-score').textContent = this.score;
      },
      
      move(direction) {
        let moved = false;
        let originalGrid = JSON.parse(JSON.stringify(this.grid));
        
        // Transpose and reverse logic based on direction
        switch (direction) {
          case 'left':
            for (let r = 0; r < this.gridSize; r++) {
              let row = this.grid[r].filter(val => val !== 0);
              for (let i = 0; i < row.length - 1; i++) {
                if (row[i] === row[i + 1]) {
                  row[i] *= 2;
                  this.score += row[i];
                  row[i + 1] = 0;
                }
              }
              row = row.filter(val => val !== 0);
              while (row.length < this.gridSize) row.push(0);
              this.grid[r] = row;
            }
            break;
            
          case 'right':
            for (let r = 0; r < this.gridSize; r++) {
              let row = this.grid[r].filter(val => val !== 0);
              for (let i = row.length - 1; i > 0; i--) {
                if (row[i] === row[i - 1]) {
                  row[i] *= 2;
                  this.score += row[i];
                  row[i - 1] = 0;
                }
              }
              row = row.filter(val => val !== 0);
              while (row.length < this.gridSize) row.unshift(0);
              this.grid[r] = row;
            }
            break;
            
          case 'up':
            for (let c = 0; c < this.gridSize; c++) {
              let col = [];
              for (let r = 0; r < this.gridSize; r++) {
                col.push(this.grid[r][c]);
              }
              col = col.filter(val => val !== 0);
              for (let i = 0; i < col.length - 1; i++) {
                if (col[i] === col[i + 1]) {
                  col[i] *= 2;
                  this.score += col[i];
                  col[i + 1] = 0;
                }
              }
              col = col.filter(val => val !== 0);
              while (col.length < this.gridSize) col.push(0);
              for (let r = 0; r < this.gridSize; r++) {
                this.grid[r][c] = col[r];
              }
            }
            break;
            
          case 'down':
            for (let c = 0; c < this.gridSize; c++) {
              let col = [];
              for (let r = 0; r < this.gridSize; r++) {
                col.push(this.grid[r][c]);
              }
              col = col.filter(val => val !== 0);
              for (let i = col.length - 1; i > 0; i--) {
                if (col[i] === col[i - 1]) {
                  col[i] *= 2;
                  this.score += col[i];
                  col[i - 1] = 0;
                }
              }
              col = col.filter(val => val !== 0);
              while (col.length < this.gridSize) col.unshift(0);
              for (let r = 0; r < this.gridSize; r++) {
                this.grid[r][c] = col[r];
              }
            }
            break;
        }
        
        // Check if grid changed
        for (let r = 0; r < this.gridSize; r++) {
          for (let c = 0; c < this.gridSize; c++) {
            if (originalGrid[r][c] !== this.grid[r][c]) {
              moved = true;
              break;
            }
          }
        }
        
        if (moved) {
          this.addRandomTile();
          this.draw();
          
          // Check for win
          for (let r = 0; r < this.gridSize; r++) {
            for (let c = 0; c < this.gridSize; c++) {
              if (this.grid[r][c] === 2048) {
                alert('Congratulations! You reached 2048!');
              }
            }
          }
        }
      }
    };

    // Initialize 2048
    document.getElementById('game-2048-start').addEventListener('click', () => {
      game2048.init();
    });
    
    // Keyboard controls for 2048
    document.addEventListener('keydown', (e) => {
      if (document.getElementById('game-2048').classList.contains('active')) {
        switch (e.key) {
          case 'ArrowUp':
            game2048.move('up');
            break;
          case 'ArrowDown':
            game2048.move('down');
            break;
          case 'ArrowLeft':
            game2048.move('left');
            break;
          case 'ArrowRight':
            game2048.move('right');
            break;
        }
      }
    });
    
    // Initialize on load
    window.addEventListener('load', () => {
      game2048.init();
    });

    // Clicker Game
    const clickerGame = {
      points: 0,
      perClick: 1,
      upgrades: [
        { id: 'upgrade1', name: 'Better Mouse', cost: 10, effect: 1, type: 'perClick', purchased: false },
        { id: 'upgrade2', name: 'Gaming Mouse', cost: 50, effect: 3, type: 'perClick', purchased: false },
        { id: 'upgrade3', name: 'Auto Clicker', cost: 100, effect: 1, type: 'auto', purchased: false },
        { id: 'upgrade4', name: 'Robotic Assistant', cost: 500, effect: 5, type: 'auto', purchased: false }
      ],
      autoClickers: 0,
      interval: null,
      
      init() {
        this.points = 0;
        this.perClick = 1;
        this.autoClickers = 0;
        
        // Reset upgrade purchases
        this.upgrades.forEach(upgrade => {
          upgrade.purchased = false;
        });
        
        this.updateDisplay();
        this.renderUpgrades();
        
        if (this.interval) clearInterval(this.interval);
        this.interval = setInterval(() => {
          this.points += this.autoClickers;
          this.updateDisplay();
        }, 1000);
      },
      
      click() {
        this.points += this.perClick;
        this.updateDisplay();
      },
      
      purchaseUpgrade(id) {
        const upgrade = this.upgrades.find(u => u.id === id);
        if (upgrade && !upgrade.purchased && this.points >= upgrade.cost) {
          this.points -= upgrade.cost;
          upgrade.purchased = true;
          
          if (upgrade.type === 'perClick') {
            this.perClick += upgrade.effect;
          } else if (upgrade.type === 'auto') {
            this.autoClickers += upgrade.effect;
          }
          
          this.updateDisplay();
          this.renderUpgrades();
        }
      },
      
      updateDisplay() {
        document.getElementById('clicker-points').textContent = this.points;
        document.getElementById('clicker-per-click').textContent = this.perClick;
      },
      
      renderUpgrades() {
        const upgradesContainer = document.getElementById('clicker-upgrades');
        upgradesContainer.innerHTML = '<h3>Upgrades:</h3>';
        
        this.upgrades.forEach(upgrade => {
          const div = document.createElement('div');
          div.style.margin = '10px 0';
          div.style.padding = '10px';
          div.style.background = 'rgba(255,255,255,0.1)';
          div.style.borderRadius = '5px';
          div.innerHTML = `
            <button class="btn" ${upgrade.purchased ? 'disabled' : ''} 
              onclick="clickerGame.purchaseUpgrade('${upgrade.id}')"
              style="${upgrade.purchased ? 'background: #95a5a6;' : ''}">
              ${upgrade.name} - Cost: ${upgrade.cost}
            </button>
            <small>${upgrade.purchased ? '(Purchased)' : ''}</small>
          `;
          upgradesContainer.appendChild(div);
        });
      }
    };

    // Initialize Clicker Game
    document.getElementById('clicker-area').addEventListener('click', () => {
      clickerGame.click();
    });
    
    document.getElementById('clicker-game-reset').addEventListener('click', () => {
      clickerGame.init();
    });
    
    // Initialize on load
    window.addEventListener('load', () => {
      clickerGame.init();
    });

    // Maze Game
    const mazeGame = {
      maze: [],
      playerPos: {x: 1, y: 1},
      exitPos: {x: 8, y: 8},
      mazeSize: 10,
      
      init() {
        this.generateMaze();
        this.playerPos = {x: 1, y: 1};
        this.exitPos = {x: this.mazeSize - 2, y: this.mazeSize - 2};
        this.draw();
      },
      
      generateMaze() {
        // Create a simple maze using recursive division
        this.maze = Array(this.mazeSize).fill().map(() => Array(this.mazeSize).fill(1));
        
        // Create paths (0 = path, 1 = wall)
        for (let r = 0; r < this.mazeSize; r++) {
          for (let c = 0; c < this.mazeSize; c++) {
            // Border walls
            if (r === 0 || r === this.mazeSize - 1 || c === 0 || c === this.mazeSize - 1) {
              this.maze[r][c] = 1;
            } else {
              // Create paths with some randomness
              this.maze[r][c] = Math.random() < 0.7 ? 0 : 1;
            }
          }
        }
        
        // Ensure start and exit are open
        this.maze[1][1] = 0;
        this.maze[this.mazeSize - 2][this.mazeSize - 2] = 0;
        
        // Ensure a path exists (simple approach)
        for (let i = 1; i < this.mazeSize - 1; i++) {
          this.maze[1][i] = 0; // Top row path
          this.maze[i][this.mazeSize - 2] = 0; // Right column path
        }
      },
      
      draw() {
        const mazeBoard = document.getElementById('maze-board');
        mazeBoard.innerHTML = '';
        
        for (let r = 0; r < this.mazeSize; r++) {
          for (let c = 0; c < this.mazeSize; c++) {
            const cell = document.createElement('div');
            cell.classList.add('cell');
            
            if (this.maze[r][c] === 1) {
              cell.classList.add('wall');
            } else {
              cell.classList.add('path');
            }
            
            if (r === this.playerPos.y && c === this.playerPos.x) {
              cell.classList.add('player');
            }
            
            if (r === this.exitPos.y && c === this.exitPos.x) {
              cell.classList.add('exit');
            }
            
            mazeBoard.appendChild(cell);
          }
        }
      },
      
      movePlayer(dx, dy) {
        const newX = this.playerPos.x + dx;
        const newY = this.playerPos.y + dy;
        
        // Check if new position is valid
        if (
          newX >= 0 && 
          newX < this.mazeSize && 
          newY >= 0 && 
          newY < this.mazeSize && 
          this.maze[newY][newX] === 0
        ) {
          this.playerPos.x = newX;
          this.playerPos.y = newY;
          this.draw();
          
          // Check if player reached exit
          if (newX === this.exitPos.x && newY === this.exitPos.y) {
            alert('Congratulations! You escaped the maze!');
          }
        }
      }
    };

    // Initialize Maze Game
    document.getElementById('maze-game-start').addEventListener('click', () => {
      mazeGame.init();
    });
    
    // Keyboard controls for maze
    document.addEventListener('keydown', (e) => {
      if (document.getElementById('maze-game').classList.contains('active')) {
        switch (e.key) {
          case 'ArrowUp':
            mazeGame.movePlayer(0, -1);
            break;
          case 'ArrowDown':
            mazeGame.movePlayer(0, 1);
            break;
          case 'ArrowLeft':
            mazeGame.movePlayer(-1, 0);
            break;
          case 'ArrowRight':
            mazeGame.movePlayer(1, 0);
            break;
        }
      }
    });
    
    // Initialize on load
    window.addEventListener('load', () => {
      mazeGame.init();
    });

    // Rock Paper Scissors Game
    const rockPaperScissors = {
      playerScore: 0,
      computerScore: 0,
      
      init() {
        this.playerScore = 0;
        this.computerScore = 0;
        document.getElementById('rps-player-score').textContent = '0';
        document.getElementById('rps-computer-score').textContent = '0';
        document.getElementById('rps-result').textContent = 'Choose your move!';
      },
      
      play(playerChoice) {
        const choices = ['rock', 'paper', 'scissors'];
        const computerChoice = choices[Math.floor(Math.random() * 3)];
        
        // Determine winner
        let result;
        if (playerChoice === computerChoice) {
          result = "It's a tie!";
        } else if (
          (playerChoice === 'rock' && computerChoice === 'scissors') ||
          (playerChoice === 'paper' && computerChoice === 'rock') ||
          (playerChoice === 'scissors' && computerChoice === 'paper')
        ) {
          result = `You win! ${this.capitalize(playerChoice)} beats ${computerChoice}.`;
          this.playerScore++;
        } else {
          result = `Computer wins! ${this.capitalize(computerChoice)} beats ${playerChoice}.`;
          this.computerScore++;
        }
        
        // Update UI
        document.getElementById('rps-result').textContent = result;
        document.getElementById('rps-player-score').textContent = this.playerScore;
        document.getElementById('rps-computer-score').textContent = this.computerScore;
      },
      
      capitalize(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
      }
    };

    // Initialize Rock Paper Scissors
    document.getElementById('rock').addEventListener('click', () => {
      rockPaperScissors.play('rock');
    });
    
    document.getElementById('paper').addEventListener('click', () => {
      rockPaperScissors.play('paper');
    });
    
    document.getElementById('scissors').addEventListener('click', () => {
      rockPaperScissors.play('scissors');
    });
    
    document.getElementById('rps-reset').addEventListener('click', () => {
      rockPaperScissors.init();
    });
    
    // Initialize on load
    window.addEventListener('load', () => {
      rockPaperScissors.init();
    });
  </script>
</body>
</html>